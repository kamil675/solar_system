<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Solar System - Scroll Controlled</title>
    <style>
      body {
        margin: 0;
        height: 400vh;
        background: black;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      .planet-label {
        color: white;
        font-size: clamp(12px, 1.2vw, 16px);
        font-weight: bold;
        pointer-events: none;
        text-align: center;
        text-shadow: 0 0 5px black;
      }
      @media (max-width: 768px) {
        body {
          height: 600vh;
        }
        .planet-label {
          max-width: 120px;
          font-size: clamp(10px, 2vw, 14px);
        }
      }

      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      #loading-text {
        color: white;
        font-size: clamp(16px, 1.5vw, 22px);
        margin-top: 20px;
      }
      #fynixText {
        position: fixed;
        top: 35%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        color: #ffffff;
        font-size: clamp(1.5rem, 2.5vw, 2.5rem);
        font-weight: 800;
        text-align: center;
        letter-spacing: 1.5px;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
          0 0 25px rgba(255, 255, 255, 0.6);
        /* transition: transform 0.2s ease, opacity 0.5s ease; */
        opacity: 0; /* <-- hidden before loader ends */
        visibility: hidden; /* <-- prevent clicks */
        z-index: 10000;
        pointer-events: none;
      }

      #astronaut {
        position: fixed;
        left: 50%;
        width: clamp(200px, 20vw, 350px);
        height: auto;
        pointer-events: none;
        opacity: 0;
        visibility: hidden;
        transform: translateX(-50%) translateY(0) scale(1);

        z-index: 11000; /* Astronaut hamesha upar */
      }
      #moon {
        position: fixed;
        bottom: -250px; /* ðŸ‘ˆ aur niche shift kar diya (was 20px) */
        left: 50%;
        transform: translateX(-50%) scale(1.5);
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        z-index: 10000;
      }

      @media (max-width: 768px) {
        #moon {
          bottom: -8%; /* ðŸ‘ˆ mobile ke liye aur niche */
          transform: translateX(-50%) scale(1.2);
        }
      }

      .info-box {
        background: white;
        color: black;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        max-width: 200px;
        text-align: left;
      }
      canvas {
        display: block;
      }
      #moon {
        width: clamp(120px, 15vw, 200px);
        height: auto;
      }
    </style>
  </head>
  <body>
    <div id="loader">
      <canvas id="loaderCanvas" width="200" height="200"></canvas>
      <div id="loading-text">Loading 0%</div>
    </div>
    <div id="fynixText">hey we are fynix</div>
    <img id="astronaut" src="textures/models/astronaut.png" alt="Astronaut" />
    <!-- Special Moon -->
    <img
      id="moon"
      src="textures/models/moon1.png"
      style="
        transform: translateX(-50%) translateY(0) scale(1.5);
        pointer-events: none;
      "
    />

    <!-- ===== Libraries ===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
      // ===== Loader Animation =====
      const loaderCanvas = document.getElementById("loaderCanvas");
      const ctx = loaderCanvas.getContext("2d");
      const loaderSunRadius = 20;
      const miniPlanets = [];
      for (let i = 0; i < 5; i++) {
        miniPlanets.push({
          radius: Math.random() * 40 + 20,
          size: Math.random() * 3 + 2,
          speed: Math.random() * 0.03 + 0.01,
          angle: Math.random() * Math.PI * 2,
          color: `hsl(${Math.random() * 360},80%,60%)`,
        });
      }
      function drawLoader() {
        ctx.clearRect(0, 0, loaderCanvas.width, loaderCanvas.height);
        ctx.save();
        ctx.translate(loaderCanvas.width / 2, loaderCanvas.height / 2);

        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, loaderSunRadius);
        grad.addColorStop(0, "#ffff33");
        grad.addColorStop(1, "rgba(255,255,0,0)");
        ctx.beginPath();
        ctx.arc(0, 0, loaderSunRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        miniPlanets.forEach((p) => {
          p.angle += p.speed;
          const x = Math.cos(p.angle) * p.radius;
          const y = Math.sin(p.angle) * p.radius;
          const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, p.size);
          planetGrad.addColorStop(0, "white");
          planetGrad.addColorStop(0.3, p.color);
          planetGrad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.beginPath();
          ctx.arc(x, y, p.size + 2, 0, Math.PI * 2);
          ctx.fillStyle = planetGrad;
          ctx.fill();
        });
        ctx.restore();
        requestAnimationFrame(drawLoader);
      }
      drawLoader();

      // ===== Three.js Scene =====
      const scene = new THREE.Scene();

      // ===== Galaxy Background Plane =====
      const textureLoader = new THREE.TextureLoader();
      const galaxyTexture = textureLoader.load(
        "textures/models/galaxy.png",
        () => console.log("Galaxy texture loaded successfully"),
        undefined,
        (err) => console.error("Error loading galaxy texture:", err)
      );

      const bgGeometry = new THREE.PlaneGeometry(2000, 2000);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: galaxyTexture,
        side: THREE.DoubleSide,
      });

      const galaxyPlane = new THREE.Mesh(bgGeometry, bgMaterial);
      galaxyPlane.position.set(0, 0, -1500); // closer to camera
      // Galaxy Sphere
      const galaxyGeometry = new THREE.SphereGeometry(1500, 64, 64); // radius same
      const galaxyMaterial = new THREE.MeshBasicMaterial({
        map: galaxyTexture,
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.3,
        blending: THREE.NormalBlending,
      });
      const galaxySphere = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
      scene.add(galaxySphere);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      );

      camera.position.set(0, 50, 350);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // CSS2DRenderer
      const labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.top = "0px";
      labelRenderer.domElement.style.pointerEvents = "none";
      document.body.appendChild(labelRenderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.enablePan = false;

      scene.add(new THREE.AmbientLight(0xffffff, 0.15));
      const fillLight1 = new THREE.PointLight(0xffffff, 0.3, 2000);
      fillLight1.position.set(500, 200, 500);
      scene.add(fillLight1);
      const fillLight2 = new THREE.PointLight(0xffffff, 0.25, 2000);
      fillLight2.position.set(-400, -200, -300);
      scene.add(fillLight2);

      // ===== Stars =====
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 20000; // zyada stars
      const starVertices = [];
      const starSpeeds = [];
      const spreadX = 4000; // x axis ka spread
      const spreadY = 4000; // y axis ka spread
      const spreadZ = 4000; // z axis ka spread
      const minSpeed = 0.05;
      const maxSpeed = 0.15;

      for (let i = 0; i < starCount; i++) {
        const x = (Math.random() - 0.5) * spreadX;
        const y = (Math.random() - 0.5) * spreadY;
        const z = (Math.random() - 0.5) * spreadZ;

        starVertices.push(x, y, z);
        starSpeeds.push(Math.random() * (maxSpeed - minSpeed) + minSpeed);
      }

      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );

      const starTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/circle.png"
      );
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2.5, // thoda bada
        map: starTexture,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      // Animate stars
      function animateStars(factor = 1) {
        const positions = stars.geometry.attributes.position.array;

        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += starSpeeds[i / 3] * factor;

          // Vertically wrap kare
          if (positions[i + 1] > spreadY / 2) {
            positions[i + 1] = -spreadY / 2;
            positions[i] = (Math.random() - 0.5) * spreadX;
            positions[i + 2] = (Math.random() - 0.5) * spreadZ;
          }
        }

        stars.geometry.attributes.position.needsUpdate = true;
      }

      // ===== Solar System Setup =====
      const gltfLoader = new THREE.GLTFLoader();
      const solarSystem = new THREE.Group();
      solarSystem.scale.set(0.01, 0.01, 0.01);
      scene.add(solarSystem);

      const planets = [
        {
          name: "Sun",
          radius: 46,
          distance: 0,
          speed: 0,
          rotation: 0.001,
          file: "the_star_sun.glb",
          info: "The Sun, star at center.",
        },
        {
          name: "Mercury",
          radius: 6,
          distance: 40,
          speed: 0.008,
          rotation: 0.004,
          file: "mercury.glb",
          info: "Closest planet to Sun.",
        },
        {
          name: "Venus",
          radius: 9,
          distance: 60,
          speed: 0.006,
          rotation: 0.002,
          file: "venus.glb",
          info: "Very hot planet.",
        },
        {
          name: "Earth",
          radius: 11,
          distance: 80,
          speed: 0.004,
          rotation: 0.01,
          file: "earth.glb",
          info: "Our home planet.",
        },
        {
          name: "Mars",
          radius: 13,
          distance: 100,
          speed: 0.003,
          rotation: 0.008,
          file: "mars.glb",
          info: "Red planet.",
        },
        {
          name: "Jupiter",
          radius: 17,
          distance: 130,
          speed: 0.0015,
          rotation: 0.005,
          file: "jupiter.glb",
          info: "Largest planet.",
        },
        {
          name: "Saturn",
          radius: 16,
          distance: 155,
          speed: 0.0012,
          rotation: 0.008,
          file: "saturn.glb",
          info: "Has rings.",
        },
        {
          name: "Uranus",
          radius: 13,
          distance: 180,
          speed: 0.0009,
          rotation: 0.003,
          file: "uranus.glb",
          info: "Rotates on side.",
        },
        {
          name: "Neptune",
          radius: 10,
          distance: 200,
          speed: 0.0009,
          rotation: 0.003,
          file: "neptune.glb",
          info: "Rotates on side.",
        },
      ];

      const planetMeshes = [];
      const orbitMeshes = [];
      let planetsLoaded = 0;
      const loaderDiv = document.getElementById("loader");
      const loadingText = document.getElementById("loading-text");
      const spriteTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
      );

      function addGlowSpriteToMesh(
        mesh,
        size,
        color = 0xffe066,
        opacity = 0.15
      ) {
        const spriteMat = new THREE.SpriteMaterial({
          map: spriteTexture,
          color,
          transparent: true,
          opacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(size, size, 1);
        mesh.add(sprite);
        sprite.position.set(0, 0, -size * 0.02);
        return sprite;
      }

      function loadPlanetModel(planet) {
        gltfLoader.load(`textures/models/${planet.file}`, (gltf) => {
          const mesh = gltf.scene;
          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          let scaleFactor = planet.radius / Math.max(size.x, size.y, size.z);
          if (planet.name === "Sun") scaleFactor *= 0.8;
          mesh.scale.setScalar(scaleFactor);

          if (planet.name === "Sun") {
            const coreLight = new THREE.PointLight(0xffd966, 1.2, 1500);
            mesh.add(coreLight);
            const redGlow = new THREE.PointLight(0xff3300, 0.2, 2500);
            mesh.add(redGlow);
            const yellowGlow = new THREE.PointLight(0xffee88, 0.5, 1500);
            mesh.add(yellowGlow);
            mesh.traverse((child) => {
              if (child.isMesh && child.material) {
                try {
                  child.material.emissive = new THREE.Color(0xffb84d);
                  child.material.emissiveIntensity = 0.3;
                } catch (e) {}
              }
            });
            addGlowSpriteToMesh(mesh, 100, 0xffe066, 0.12);
          } else
            addGlowSpriteToMesh(mesh, planet.radius * 10 + 40, 0xffffff, 0.08);

          const pivot = new THREE.Object3D();
          pivot.rotation.y = Math.random() * Math.PI * 2;
          pivot.userData.speed = planet.speed;
          mesh.position.set(planet.distance, 0, 0);
          pivot.add(mesh);
          solarSystem.add(pivot);

          let label = null;
          if (planet.name !== "Mars") {
            const div = document.createElement("div");
            div.className = "planet-label";
            div.textContent = `${planet.name}: ${planet.info}`;
            label = new THREE.CSS2DObject(div);
            label.position.set(0, planet.radius + 5, 0);
            label.visible = false;
            mesh.add(label);
          }
          mesh.userData.label = label;
          mesh.userData.isPlanet = true;

          if (planet.distance > 0) {
            const ringWidth = Math.max(0.06, planet.radius * 0.02 + 0.02);
            const orbit = new THREE.RingGeometry(
              planet.distance - ringWidth,
              planet.distance + ringWidth,
              256
            );
            const orbitMat = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.25,
              blending: THREE.AdditiveBlending,
              depthWrite: false,
            });
            const orbitMesh = new THREE.Mesh(orbit, orbitMat);
            orbitMesh.rotation.x = Math.PI / 2;
            solarSystem.add(orbitMesh);
            orbitMeshes.push(orbitMesh);
          }

          planetMeshes.push({ mesh, pivot, planet });
          planetsLoaded++;
          loadingText.textContent = `Loading ${Math.floor(
            (planetsLoaded / planets.length) * 100
          )}%`;

          if (planetsLoaded === planets.length) {
            loaderDiv.style.opacity = 0;
            loaderDiv.style.display = "none";
            document.getElementById("astronaut").style.visibility = "visible";
            document.getElementById("astronaut").style.opacity = 1;
            document.getElementById("moon").style.visibility = "visible";
            document.getElementById("moon").style.opacity = 1;
            const fynixText = document.getElementById("fynixText");
            fynixText.style.visibility = "visible";
            fynixText.style.opacity = 1;
          }
        });
      }
      planets.forEach(loadPlanetModel);

      let scrollProgress = 0,
        targetScroll = 0;
      const scrollHeight = window.innerHeight * 4;

      window.addEventListener("wheel", (e) => {
        targetScroll += e.deltaY;
        targetScroll = Math.min(Math.max(targetScroll, 0), scrollHeight);
      });

      function updateScrollAnimation() {
        // Smooth interpolation
        scrollProgress += (targetScroll - scrollProgress) * 0.1;
        const eased = Math.min(Math.max(scrollProgress / scrollHeight, 0), 1);

        // ===== Scale factor for responsive =====
        const scaleFactor = window.innerWidth < 768 ? 0.7 : 1;

        // ===== Astronaut =====
        const astronaut = document.getElementById("astronaut");

        // Fixed bottom positions in px (not multiplied by scale or zoom)
        let startBottom = window.innerHeight * 0.25; // starting point
        let endBottom = window.innerHeight * 0.57; // ending point

        // Scale values
        let startScale = 2.5;
        let endScale = 0.5;

        const astroBottomPx = startBottom + (endBottom - startBottom) * eased;
        const astroScale = startScale - (startScale - endScale) * eased;

        astronaut.style.bottom = `${astroBottomPx}px`;
        astronaut.style.transform = `translateX(-50%) scale(${astroScale})`;
        astronaut.style.opacity = 1 - eased;

        // ===== Moon =====
        const moon = document.getElementById("moon");
        const moonScale =
          window.innerWidth < 768 ? 2.2 - 2.19 * eased : 3.5 - 3.49 * eased;
        const moonOpacity = 1 - Math.pow(eased, 1.5);
        const moonScrollOffset =
          window.innerWidth < 768
            ? eased * -window.innerHeight * 0.6
            : eased * -window.innerHeight * 0.85;
        moon.style.transform = `translateX(-50%) translateY(${moonScrollOffset}px) scale(${moonScale})`;
        moon.style.opacity = moonOpacity;

        // ===== Fynix Text =====
        const fynixText = document.getElementById("fynixText");
        let fynixProgress = eased;
        fynixProgress = Math.min(Math.max(fynixProgress, 0), 1);
        const fynixScale = 1.2 - 0.7 * fynixProgress;
        const fynixOpacity = 1 - fynixProgress;
        const fynixTop = 35 - 20 * fynixProgress;
        fynixText.style.transform = `translate(-50%, -50%) scale(${
          fynixScale * scaleFactor
        })`;
        fynixText.style.opacity = fynixOpacity;
        fynixText.style.top = `${fynixTop}%`;

        // ===== Solar System =====
        const solarProgress = Math.min(Math.max((eased - 0.55) / 0.45, 0), 1);
        const baseScale = 0.15 + (0.8 - 0.15) * solarProgress;
        solarSystem.scale.setScalar(baseScale * scaleFactor); // apply mobile scale

        solarSystem.position.y =
          -window.innerHeight * 0.99 +
          window.innerHeight * 0.99 * solarProgress;

        // Camera zoom slightly more on mobile
        camera.position.z = (350 - 150 * solarProgress) * scaleFactor;
        camera.lookAt(0, 0, 0);
      }

      function updateMeshMap() {
        planetMeshes.forEach((p) => {
          if (p.planet.distance > 0) p.pivot.rotation.y += p.planet.speed || 0;
          p.mesh.rotation.y += p.planet.rotation || 0;
        });
        orbitMeshes.forEach((mesh) => (mesh.rotation.z += 0.0002));
      }

      // ===== Hover Info =====
      const raycaster = new THREE.Raycaster();
      let mouseX = 0,
        mouseY = 0;
      const mouse = new THREE.Vector2();
      let lastHoveredPlanet = null;

      window.addEventListener("mousemove", (event) => {
        // ===== Parallax =====
        mouseX = (event.clientX / window.innerWidth - 0.5) * 2;
        mouseY = (event.clientY / window.innerHeight - 0.5) * 2;

        // ===== Hover detection =====
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(
          planetMeshes.map((p) => p.mesh),
          true
        );

        if (lastHoveredPlanet && lastHoveredPlanet.userData.label)
          lastHoveredPlanet.userData.label.visible = false;
        lastHoveredPlanet = null;

        if (intersects.length > 0) {
          let planet = intersects[0].object;
          while (planet && !planet.userData.isPlanet) planet = planet.parent;
          if (planet && planet.userData.label) {
            planet.userData.label.visible = true;
            lastHoveredPlanet = planet;
          }
        }
      });

      function animate() {
        requestAnimationFrame(animate);
        // Animate background movement
        galaxyPlane.position.x = mouseX * 50; // adjust multiplier for speed
        galaxyPlane.position.y = -mouseY * 50;

        updateMeshMap();
        animateStars(2);
        updateScrollAnimation();
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
