<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Solar System - Scroll Controlled</title>
    <style>
      body {
        margin: 0;
        height: 400vh;
        background: black;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }
      .planet-label {
        color: white;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        text-align: center;
        text-shadow: 0 0 5px black;
      }
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      #loading-text {
        color: white;
        font-size: 18px;
        margin-top: 20px;
      }
      #astronaut {
        position: fixed;
        bottom: 30%;
        left: 50%;
        width: 350px;
        height: 250px;
        z-index: 11000;
        pointer-events: none;
        opacity: 0;
        visibility: hidden;
        transform: translateX(-50%) translateY(0) scale(1);
      }

      .info-box {
        background: white;
        color: black;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        max-width: 200px;
        text-align: left;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="loader">
      <canvas id="loaderCanvas" width="200" height="200"></canvas>
      <div id="loading-text">Loading 0%</div>
    </div>
    <img id="astronaut" src="textures/models/astronaut.png" alt="Astronaut" />

    <!-- ===== Libraries ===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
      // ===== Loader Animation =====
      const loaderCanvas = document.getElementById("loaderCanvas");
      const ctx = loaderCanvas.getContext("2d");
      const loaderSunRadius = 20;
      const miniPlanets = [];
      for (let i = 0; i < 5; i++) {
        miniPlanets.push({
          radius: Math.random() * 40 + 20,
          size: Math.random() * 3 + 2,
          speed: Math.random() * 0.03 + 0.01,
          angle: Math.random() * Math.PI * 2,
          color: `hsl(${Math.random() * 360},80%,60%)`,
        });
      }
      function drawLoader() {
        ctx.clearRect(0, 0, loaderCanvas.width, loaderCanvas.height);
        ctx.save();
        ctx.translate(loaderCanvas.width / 2, loaderCanvas.height / 2);

        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, loaderSunRadius);
        grad.addColorStop(0, "#ffff33");
        grad.addColorStop(1, "rgba(255,255,0,0)");
        ctx.beginPath();
        ctx.arc(0, 0, loaderSunRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        miniPlanets.forEach((p) => {
          p.angle += p.speed;
          const x = Math.cos(p.angle) * p.radius;
          const y = Math.sin(p.angle) * p.radius;
          const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, p.size);
          planetGrad.addColorStop(0, "white");
          planetGrad.addColorStop(0.3, p.color);
          planetGrad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.beginPath();
          ctx.arc(x, y, p.size + 2, 0, Math.PI * 2);
          ctx.fillStyle = planetGrad;
          ctx.fill();
        });
        ctx.restore();
        requestAnimationFrame(drawLoader);
      }
      drawLoader();

      // ===== Three.js Scene =====
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 50, 350);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // label renderer
      const labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.top = "0px";
      labelRenderer.domElement.style.pointerEvents = "none";
      document.body.appendChild(labelRenderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.enablePan = false;

      scene.add(new THREE.AmbientLight(0xffffff, 0.15));
      const fillLight1 = new THREE.PointLight(0xffffff, 0.3, 2000);
      fillLight1.position.set(500, 200, 500);
      scene.add(fillLight1);
      const fillLight2 = new THREE.PointLight(0xffffff, 0.25, 2000);
      fillLight2.position.set(-400, -200, -300);
      scene.add(fillLight2);

      // ===== Stars =====
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2500;
      const starVertices = [];
      const starSpeeds = [];
      const spread = 6000;

      for (let i = 0; i < starCount; i++) {
        const r = Math.random() * spread;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        starVertices.push(x, y, z);
        starSpeeds.push(Math.random() * 0.05 + 0.01);
      }

      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );

      const starTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/circle.png"
      );
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,
        map: starTexture,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      function animateStars(factor = 1) {
        const positions = stars.geometry.attributes.position.array;
        const verticalLimit = spread / 2;

        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += starSpeeds[i / 3] * factor;

          if (positions[i + 1] > verticalLimit) {
            positions[i + 1] = -verticalLimit;
            positions[i] = (Math.random() - 0.5) * spread;
            positions[i + 2] = (Math.random() - 0.5) * spread;
          }
        }

        stars.geometry.attributes.position.needsUpdate = true;
      }

      // ===== Solar System =====
      const gltfLoader = new THREE.GLTFLoader();
      const solarSystem = new THREE.Group();
      solarSystem.scale.set(0.01, 0.01, 0.01);
      scene.add(solarSystem);

      const planets = [
        {
          name: "Sun",
          radius: 46,
          distance: 0,
          speed: 0,
          rotation: 0.001,
          file: "the_star_sun.glb",
          info: "The Sun, star at center.",
        },
        {
          name: "Mercury",
          radius: 6,
          distance: 40,
          speed: 0.008,
          rotation: 0.004,
          file: "mercury.glb",
          info: "Closest planet to Sun.",
        },
        {
          name: "Venus",
          radius: 9,
          distance: 60,
          speed: 0.006,
          rotation: 0.002,
          file: "venus.glb",
          info: "Very hot planet.",
        },
        {
          name: "Earth",
          radius: 11,
          distance: 80,
          speed: 0.004,
          rotation: 0.01,
          file: "earth.glb",
          info: "Our home planet.",
        },
        {
          name: "Mars",
          radius: 13,
          distance: 100,
          speed: 0.003,
          rotation: 0.008,
          file: "mars.glb",
          info: "Red planet.",
        },
        {
          name: "Jupiter",
          radius: 17,
          distance: 130,
          speed: 0.0015,
          rotation: 0.005,
          file: "jupiter.glb",
          info: "Largest planet.",
        },
        {
          name: "Saturn",
          radius: 16,
          distance: 155,
          speed: 0.0012,
          rotation: 0.008,
          file: "saturn.glb",
          info: "Has rings.",
        },
        {
          name: "Uranus",
          radius: 13,
          distance: 180,
          speed: 0.0009,
          rotation: 0.003,
          file: "uranus.glb",
          info: "Rotates on side.",
        },
        {
          name: "Neptune",
          radius: 10,
          distance: 200,
          speed: 0.0009,
          rotation: 0.003,
          file: "neptune.glb",
          info: "Rotates on side.",
        },
      ];

      const planetMeshes = [];
      const orbitMeshes = [];
      let planetsLoaded = 0;
      const loaderDiv = document.getElementById("loader");
      const loadingText = document.getElementById("loading-text");
      const spriteTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
      );

      function addGlowSpriteToMesh(
        mesh,
        size,
        color = 0xffe066,
        opacity = 0.15
      ) {
        const spriteMat = new THREE.SpriteMaterial({
          map: spriteTexture,
          color,
          transparent: true,
          opacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(size, size, 1);
        mesh.add(sprite);
        sprite.position.set(0, 0, -size * 0.02);
        return sprite;
      }

      // ===== Special Moon =====
      const specialMoon = document.createElement("img");
      specialMoon.src = "textures/models/moon1.png";
      specialMoon.id = "moon";
      specialMoon.style.position = "fixed";
      specialMoon.style.bottom = "1%";
      specialMoon.style.left = "50%";
      specialMoon.style.width = "200px";
      specialMoon.style.height = "200px";
      specialMoon.style.opacity = "0";
      specialMoon.style.visibility = "hidden";
      specialMoon.style.transform = "translateX(-50%) translateY(0) scale(1.5)";
      specialMoon.style.pointerEvents = "none";
      specialMoon.style.transition = "transform 0.1s ease, opacity 0.3s ease";
      specialMoon.style.zIndex = "10000";

      document.body.appendChild(specialMoon);

      const infoDiv = document.createElement("div");
      infoDiv.className = "info-box";
      infoDiv.textContent =
        "Moon is Earth's only natural satellite with 27% of Earth's size.";
      infoDiv.style.display = "none";
      document.body.appendChild(infoDiv);
      specialMoon.info = infoDiv;

      // ===== Load Planets =====
      function loadPlanetModel(planet) {
        gltfLoader.load(`textures/models/${planet.file}`, (gltf) => {
          const mesh = gltf.scene;
          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          let scaleFactor = planet.radius / Math.max(size.x, size.y, size.z);
          if (planet.name === "Sun") scaleFactor *= 0.8;
          mesh.scale.setScalar(scaleFactor);

          if (planet.name === "Sun") {
            const coreLight = new THREE.PointLight(0xffd966, 1.2, 1500);
            mesh.add(coreLight);
            const redGlow = new THREE.PointLight(0xff3300, 0.2, 2500);
            mesh.add(redGlow);
            const yellowGlow = new THREE.PointLight(0xffee88, 0.5, 1500);
            mesh.add(yellowGlow);
            mesh.traverse((child) => {
              if (child.isMesh && child.material) {
                try {
                  child.material.emissive = new THREE.Color(0xffb84d);
                  child.material.emissiveIntensity = 0.3;
                } catch (e) {}
              }
            });
            addGlowSpriteToMesh(mesh, 100, 0xffe066, 0.12);
          } else {
            addGlowSpriteToMesh(mesh, planet.radius * 10 + 40, 0xffffff, 0.08);
          }

          const pivot = new THREE.Object3D();
          pivot.rotation.y = Math.random() * Math.PI * 2;
          pivot.userData.speed = planet.speed;
          mesh.position.set(planet.distance, 0, 0);
          pivot.add(mesh);
          solarSystem.add(pivot);

          if (planet.distance > 0) {
            const ringWidth = Math.max(0.06, planet.radius * 0.02 + 0.02);
            const orbit = new THREE.RingGeometry(
              planet.distance - ringWidth,
              planet.distance + ringWidth,
              256
            );
            const orbitMat = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.25,
              blending: THREE.AdditiveBlending,
              depthWrite: false,
            });
            const orbitMesh = new THREE.Mesh(orbit, orbitMat);
            orbitMesh.rotation.x = Math.PI / 2;
            solarSystem.add(orbitMesh);
            orbitMeshes.push(orbitMesh);
          }

          planetMeshes.push({ mesh, pivot, planet });
          planetsLoaded++;
          loadingText.textContent = `Loading ${Math.floor(
            (planetsLoaded / planets.length) * 100
          )}%`;

          if (planetsLoaded === planets.length) {
            loaderDiv.style.opacity = 0;
            loaderDiv.style.display = "none";

            // Show astronaut
            const astronautImg = document.getElementById("astronaut");
            astronautImg.style.visibility = "visible";
            astronautImg.style.opacity = 1;

            // Show Moon **now**
            specialMoon.style.visibility = "visible";
            specialMoon.style.opacity = 1;
          }
        });
      }

      planets.forEach(loadPlanetModel);

      // ===== Scroll handling =====
      let scrollProgress = 0,
        targetScroll = 0;
      const scrollHeight = window.innerHeight * 4;
      let touchStartY = 0;

      window.addEventListener("wheel", (e) => {
        targetScroll += e.deltaY;
        targetScroll = Math.min(Math.max(targetScroll, 0), scrollHeight);
      });
      window.addEventListener("touchstart", (e) => {
        touchStartY = e.touches[0].clientY;
      });
      window.addEventListener("touchmove", (e) => {
        const deltaY = touchStartY - e.touches[0].clientY;
        targetScroll += deltaY;
        targetScroll = Math.min(Math.max(targetScroll, 0), scrollHeight);
        touchStartY = e.touches[0].clientY;
      });

      function updateScrollAnimation() {
        scrollProgress += (targetScroll - scrollProgress) * 0.08;
        const eased = Math.min(Math.max(scrollProgress / scrollHeight, 0), 1);

        const astronaut = document.getElementById("astronaut");

        const astroStartBottom = 30;
        const astroEndBottom = 50;

        const astroStartScale = 2;
        const astroEndScale = 0;
        const astroScale =
          astroStartScale - (astroStartScale - astroEndScale) * eased;

        // Move upward
        const astroBottom =
          astroStartBottom + (astroEndBottom - astroStartBottom) * eased;

        // Fade out at center
        const astroOpacity = 1 - eased;

        astronaut.style.bottom = `${astroBottom}%`;
        astronaut.style.transform = `translateX(-50%) translateY(0) scale(${astroScale})`;
        astronaut.style.opacity = astroOpacity;

        const moon = specialMoon;
        const moonStartBottom = -33;
        const moonEndBottom = 53;

        const startScale = 3.5;
        const endScale = 0.01;
        const moonTargetScale = startScale - (startScale - endScale) * eased;

        // Move from bottom to top
        const targetBottom =
          moonStartBottom + (moonEndBottom - moonStartBottom) * eased;

        const moonOpacity = 1 - Math.pow(eased, 1.5);

        moon.style.bottom = `${targetBottom}%`;
        moon.style.transform = `translateX(-50%) translateY(0) scale(${moonTargetScale})`;
        moon.style.opacity = moonOpacity;

        // Solar System
        const solarProgress = Math.min(Math.max((eased - 0.15) / 0.85, 0), 1);
        solarSystem.position.y =
          -window.innerHeight * 0.99 +
          window.innerHeight * 0.99 * solarProgress;
        const scaleVal = 0.2 + (0.8 - 0.2) * solarProgress;
        solarSystem.scale.setScalar(scaleVal);
        camera.position.z = 350 - 150 * solarProgress;
        camera.lookAt(0, 0, 0);
      }

      function updateMeshMap() {
        planetMeshes.forEach((p) => {
          if (p.planet.distance > 0) p.pivot.rotation.y += p.planet.speed || 0;
          p.mesh.rotation.y += p.planet.rotation || 0;
        });
        orbitMeshes.forEach((mesh) => (mesh.rotation.z += 0.0002));
      }
      // ===== Hover Info Setup =====
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      window.addEventListener("mousemove", (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      function updateHoverLabels() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(
          planetMeshes.map((p) => p.mesh),
          true
        );

        planetMeshes.forEach((p) => {
          if (p.label) p.label.visible = false;
        });

        if (intersects.length > 0) {
          const intersected = planetMeshes.find(
            (p) =>
              intersects[0].object === p.mesh ||
              p.mesh.children.includes(intersects[0].object)
          );
          if (intersected && intersected.label) {
            intersected.label.visible = true;
          }
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        updateMeshMap();
        animateStars(1);
        updateScrollAnimation();
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
