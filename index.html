<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Solar System - Smooth Stars Entrance (Updated Rings)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: Arial, sans-serif;
      }
      .planet-label {
        color: white;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        text-align: center;
        text-shadow: 0 0 5px black;
      }
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      #loading-text {
        color: white;
        font-size: 18px;
        margin-top: 20px;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="loader">
      <canvas id="loaderCanvas" width="200" height="200"></canvas>
      <div id="loading-text">Loading 0%</div>
    </div>

    <!-- ===== Libraries ===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
      // ===== Loader Animation =====
      const loaderCanvas = document.getElementById("loaderCanvas");
      const ctx = loaderCanvas.getContext("2d");
      const loaderSunRadius = 20;
      const miniPlanets = [];
      const miniPlanetCount = 6;
      for (let i = 0; i < miniPlanetCount; i++) {
        miniPlanets.push({
          radius: Math.random() * 60 + 30,
          size: Math.random() * 4 + 2,
          speed: Math.random() * 0.03 + 0.01,
          angle: Math.random() * Math.PI * 2,
          color: `hsl(${Math.random() * 360},80%,60%)`,
        });
      }
      function drawLoader() {
        ctx.clearRect(0, 0, loaderCanvas.width, loaderCanvas.height);
        ctx.save();
        ctx.translate(loaderCanvas.width / 2, loaderCanvas.height / 2);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, loaderSunRadius);
        grad.addColorStop(0, "#ffff33");
        grad.addColorStop(1, "rgba(255,255,0,0)");
        ctx.beginPath();
        ctx.arc(0, 0, loaderSunRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        miniPlanets.forEach((p) => {
          p.angle += p.speed;
          const x = Math.cos(p.angle) * p.radius;
          const y = Math.sin(p.angle) * p.radius;
          const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, p.size);
          planetGrad.addColorStop(0, "white");
          planetGrad.addColorStop(0.3, p.color);
          planetGrad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.beginPath();
          ctx.arc(x, y, p.size + 2, 0, Math.PI * 2);
          ctx.fillStyle = planetGrad;
          ctx.fill();
        });
        ctx.restore();
        requestAnimationFrame(drawLoader);
      }
      drawLoader();

      // ===== 3D Scene =====
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 50, 250);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      // ===== Label Renderer =====
      const labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.top = "0px";
      labelRenderer.domElement.style.pointerEvents = "none";
      document.body.appendChild(labelRenderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // ===== Lights =====
      const sunLight = new THREE.PointLight(0xffee88, 3, 1000);
      sunLight.position.set(0, 0, 0);
      scene.add(sunLight);
      const fillLight1 = new THREE.PointLight(0xffffff, 0.3, 2000);
      fillLight1.position.set(500, 200, 500);
      scene.add(fillLight1);
      const fillLight2 = new THREE.PointLight(0xffffff, 0.25, 2000);
      fillLight2.position.set(-400, -200, -300);
      scene.add(fillLight2);
      scene.add(new THREE.AmbientLight(0xffffff, 0.15));

      // ===== Stars =====
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const starVertices = [];
      const starSpeeds = [];
      for (let i = 0; i < starCount; i++) {
        starVertices.push(
          (Math.random() - 0.5) * 1000,
          (Math.random() - 0.5) * 1000,
          -Math.random() * 1000
        );
        starSpeeds.push(Math.random() * 0.2 + 0.1);
      }
      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );

      const starTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/circle.png"
      );

      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.2,
        map: starTexture,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      function animateStars(factor = 1) {
        const positions = stars.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 2] += starSpeeds[i / 3] * factor;
          if (positions[i + 2] > 1000) {
            positions[i + 2] = -5000 - Math.random() * 1000;
            positions[i] = (Math.random() - 0.5) * 4000;
            positions[i + 1] = (Math.random() - 0.5) * 4000;
          }
        }
        stars.geometry.attributes.position.needsUpdate = true;
      }

      // ===== Solar System =====
      const gltfLoader = new THREE.GLTFLoader();
      const solarSystem = new THREE.Group();
      solarSystem.scale.set(0.01, 0.01, 0.01);
      scene.add(solarSystem);

      const planets = [
        {
          name: "Sun",
          radius: 46,
          distance: 0,
          speed: 0,
          rotation: 0.001,
          file: "the_star_sun.glb",
          info: "The Sun, star at center.",
        },
        {
          name: "Mercury",
          radius: 6,
          distance: 40,
          speed: 0.008,
          rotation: 0.004,
          file: "mercury.glb",
          info: "Closest planet to Sun.",
        },
        {
          name: "Venus",
          radius: 9,
          distance: 60,
          speed: 0.006,
          rotation: 0.002,
          file: "venus.glb",
          info: "Very hot planet.",
        },
        {
          name: "Earth",
          radius: 11,
          distance: 80,
          speed: 0.004,
          rotation: 0.01,
          file: "earth.glb",
          info: "Our home planet.",
        },
        {
          name: "Mars",
          radius: 13,
          distance: 100,
          speed: 0.003,
          rotation: 0.008,
          file: "mars.glb",
          info: "Red planet.",
        },
        {
          name: "Jupiter",
          radius: 17,
          distance: 130,
          speed: 0.0015,
          rotation: 0.005,
          file: "jupiter.glb",
          info: "Largest planet.",
        },
        {
          name: "Saturn",
          radius: 16,
          distance: 155,
          speed: 0.0012,
          rotation: 0.008,
          file: "saturn.glb",
          info: "Has rings.",
        },
        {
          name: "Uranus",
          radius: 13,
          distance: 180,
          speed: 0.0009,
          rotation: 0.003,
          file: "uranus.glb",
          info: "Rotates on side.",
        },
        {
          name: "Neptune",
          radius: 10,
          distance: 200,
          speed: 0.0009,
          rotation: 0.003,
          file: "neptune.glb",
          info: "Rotates on side.",
        },
      ];

      const planetMeshes = [];
      const orbitMeshes = [];
      let planetsLoaded = 0;
      const loaderDiv = document.getElementById("loader");
      const loadingText = document.getElementById("loading-text");

      planets.forEach((planet) => {
        gltfLoader.load(`textures/models/${planet.file}`, (gltf) => {
          const mesh = gltf.scene;

          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          let scaleFactor = planet.radius / Math.max(size.x, size.y, size.z);
          if (planet.name === "Sun") scaleFactor *= 0.8;
          mesh.scale.setScalar(scaleFactor);

          // ===== Add hyper-realistic Sun glow (reduced intensity) =====
          if (planet.name === "Sun") {
            // ðŸŒ• Core bright golden-yellow light (main sunlight)
            const coreLight = new THREE.PointLight(0xffd966, 1.5, 900);
            mesh.add(coreLight);

            // ðŸ”´ Outer reddish heat haze
            const redGlow = new THREE.PointLight(0xff3300, 0.15, 1200);
            mesh.add(redGlow);

            // ðŸŸ¡ Soft yellow rim light for brightness balance
            const yellowGlow = new THREE.PointLight(0xffee88, 0.4, 700);
            mesh.add(yellowGlow);

            // âœ¨ Surface emissive tint (golden-orange)
            mesh.traverse((child) => {
              if (child.isMesh && child.material) {
                child.material.emissive = new THREE.Color(0xffb84d);
                child.material.emissiveIntensity = 0.2;
              }
            });

            // ðŸŒŸ Add soft corona halo (outer sunlight haze)
            const textureLoader = new THREE.TextureLoader();
            const glowTexture = textureLoader.load(
              "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
            );
            const glowMaterial = new THREE.SpriteMaterial({
              map: glowTexture,
              color: 0xffe066,
              transparent: true,
              opacity: 0.25,
              blending: THREE.AdditiveBlending,
              depthWrite: false,
            });
            const glowSprite = new THREE.Sprite(glowMaterial);
            glowSprite.scale.set(180, 180, 1);
            mesh.add(glowSprite);

            // ðŸ”¥ Flickering animation for natural sunlight effect (reduced amplitude)
            const flicker = { t: 0 };
            const updateFlicker = () => {
              flicker.t += 0.035;
              coreLight.intensity = 1.5 + Math.sin(flicker.t * 1.2) * 0.1;
              yellowGlow.intensity = 0.4 + Math.sin(flicker.t * 0.8) * 0.05;
              redGlow.intensity = 0.15 + Math.sin(flicker.t * 0.6) * 0.03;
              glowSprite.material.opacity =
                0.25 + Math.sin(flicker.t * 0.4) * 0.02;
              requestAnimationFrame(updateFlicker);
            };
            updateFlicker();
          }

          const pivot = new THREE.Object3D();
          pivot.userData.angle = Math.random() * Math.PI * 2;
          pivot.add(mesh);
          solarSystem.add(pivot);
          mesh.position.x = planet.distance;

          // ===== Orbit Rings =====
          if (planet.distance > 0) {
            const orbit = new THREE.RingGeometry(
              planet.distance - 0.08,
              planet.distance + 0.08,
              128
            );
            const orbitMat = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending,
            });
            const orbitMesh = new THREE.Mesh(orbit, orbitMat);
            orbitMesh.rotation.x = Math.PI / 2;
            orbitMesh.visible = false; // hide initially
            solarSystem.add(orbitMesh); // add to solarSystem
            orbitMeshes.push(orbitMesh);
          }

          // ===== Labels =====
          const div = document.createElement("div");
          div.className = "planet-label";
          div.textContent = `${planet.name}: ${planet.info}`;
          const label = new THREE.CSS2DObject(div);
          let labelY = planet.radius + 5;
          if (planet.name === "Earth") labelY = planet.radius - 11;
          if (planet.name === "Mars") labelY = planet.radius - 12;
          if (planet.name === "Uranus") labelY = planet.radius - 11;
          if (planet.name === "Sun") labelY = planet.radius - 22;
          label.position.set(0, labelY, 0);
          label.visible = false;
          mesh.add(label);

          planetMeshes.push({ mesh, pivot, planet, label });
          planetsLoaded++;
          loadingText.textContent = `Loading ${Math.floor(
            (planetsLoaded / planets.length) * 100
          )}%`;

          if (planetsLoaded === planets.length) {
            gsap.to(loaderDiv, {
              opacity: 0,
              duration: 1,
              onComplete: () => {
                loaderDiv.style.display = "none";

                // Animate Solar System Scale Up
                solarSystem.scale.set(0.01, 0.01, 0.01);
                gsap.to(solarSystem.scale, {
                  x: 1,
                  y: 1,
                  z: 1,
                  duration: 2,
                  ease: "power2.out",
                  onUpdate: () => {
                    orbitMeshes.forEach((ring) => (ring.visible = true));
                  },
                });

                // Camera entrance
                gsap.fromTo(
                  camera.position,
                  { z: 500, y: 100 },
                  {
                    z: 250,
                    y: 50,
                    duration: 3,
                    ease: "power2.out",
                    onUpdate: () => camera.lookAt(0, 0, 0),
                  }
                );

                // Stars warp
                const starEntrance = { factor: 1 };
                gsap.to(starEntrance, {
                  factor: 10,
                  duration: 2.5,
                  ease: "power2.out",
                  onUpdate: () => animateStars(starEntrance.factor),
                });
              },
            });
          }
        });
      });

      // ===== Raycaster for Hover Labels =====
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      // ===== Animate Loop =====
      function animate() {
        requestAnimationFrame(animate);

        planetMeshes.forEach((p) => {
          if (p.planet.distance > 0) {
            p.pivot.userData.angle += p.planet.speed;
            const a = p.pivot.userData.angle;
            p.mesh.position.x = Math.cos(a) * p.planet.distance;
            p.mesh.position.z = Math.sin(a) * p.planet.distance;
          }
          p.mesh.rotation.y += p.planet.rotation;
          p.label.visible = false;
        });

        animateStars();

        if (planetsLoaded === planets.length) {
          raycaster.setFromCamera(mouse, camera);
          const objectsToIntersect = [];
          planetMeshes.forEach((p) =>
            p.mesh.traverse((c) => c.isMesh && objectsToIntersect.push(c))
          );
          const intersects = raycaster.intersectObjects(objectsToIntersect);
          if (intersects.length > 0) {
            let obj = intersects[0].object;
            let p = null;
            while (obj) {
              p = planetMeshes.find(
                (pm) => pm.mesh === obj || pm.mesh.children.includes(obj)
              );
              if (p) break;
              obj = obj.parent;
            }
            if (p) p.label.visible = true;
          }
        }

        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
