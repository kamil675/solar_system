<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Solar System - Updated</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: Arial, sans-serif;
      }
      .planet-label {
        color: white;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        text-align: center;
        text-shadow: 0 0 5px black;
      }
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      #loading-text {
        color: white;
        font-size: 18px;
        margin-top: 20px;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="loader">
      <canvas id="loaderCanvas" width="200" height="200"></canvas>
      <div id="loading-text">Loading 0%</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
      // ===== Loader Animation =====
      const loaderCanvas = document.getElementById("loaderCanvas");
      const ctx = loaderCanvas.getContext("2d");
      const loaderSunRadius = 20;
      const miniPlanets = [];
      const miniPlanetCount = 6;

      for (let i = 0; i < miniPlanetCount; i++) {
        miniPlanets.push({
          radius: Math.random() * 60 + 30,
          size: Math.random() * 4 + 2,
          speed: Math.random() * 0.03 + 0.01,
          angle: Math.random() * Math.PI * 2,
          color: `hsl(${Math.random() * 360}, 80%, 60%)`,
        });
      }

      function drawLoader() {
        ctx.clearRect(0, 0, loaderCanvas.width, loaderCanvas.height);
        ctx.save();
        ctx.translate(loaderCanvas.width / 2, loaderCanvas.height / 2);

        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, loaderSunRadius);
        grad.addColorStop(0, "#ffff33");
        grad.addColorStop(1, "rgba(255,255,0,0)");
        ctx.beginPath();
        ctx.arc(0, 0, loaderSunRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        miniPlanets.forEach((p) => {
          p.angle += p.speed;
          const x = Math.cos(p.angle) * p.radius;
          const y = Math.sin(p.angle) * p.radius;
          const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, p.size);
          planetGrad.addColorStop(0, p.color);
          planetGrad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.beginPath();
          ctx.arc(x, y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = planetGrad;
          ctx.fill();
        });

        ctx.restore();
        requestAnimationFrame(drawLoader);
      }
      drawLoader();

      // ===== 3D Solar System =====
      const scene = new THREE.Scene();
      const loaderTexture = new THREE.TextureLoader();
      loaderTexture.load("textures/models/stars.webp", function (texture) {
        texture.repeat.y = 0.9;
        texture.offset.y = 0.1;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        scene.background = texture;
      });

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 50, 200);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.top = "0px";
      labelRenderer.domElement.style.pointerEvents = "none";
      document.body.appendChild(labelRenderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      scene.add(new THREE.PointLight(0xffffff, 3, 0));
      scene.add(new THREE.AmbientLight(0x404040, 0.5));
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.3));

      const gltfLoader = new THREE.GLTFLoader();
      const solarSystem = new THREE.Group();
      scene.add(solarSystem);
      solarSystem.scale.set(0, 0, 0);

      // ===== Planets Data =====
      const planets = [
        {
          name: "Sun",
          radius: 48,
          distance: 0,
          speed: 0,
          rotation: 0.001,
          file: "the_star_sun.glb",
          info: "The Sun, star at center.",
        },
        {
          name: "Mercury",
          radius: 6,
          distance: 40,
          speed: 0.008, // ðŸ”¹ Slowed down
          rotation: 0.004,
          file: "mercury.glb",
          info: "Closest planet to Sun.",
        },
        {
          name: "Venus",
          radius: 9,
          distance: 60,
          speed: 0.006, // ðŸ”¹ Slowed down
          rotation: 0.002,
          file: "venus.glb",
          info: "Very hot planet.",
        },
        {
          name: "Earth",
          radius: 11,
          distance: 80,
          speed: 0.004, // ðŸ”¹ Slowed down
          rotation: 0.01,
          file: "earth.glb",
          info: "Our home planet.",
        },
        {
          name: "Mars",
          radius: 13,
          distance: 100,
          speed: 0.003, // ðŸ”¹ Slowed down
          rotation: 0.008,
          file: "mars.glb",
          info: "Red planet.",
        },
        {
          name: "Jupiter",
          radius: 16,
          distance: 130,
          speed: 0.0015, // ðŸ”¹ Slowed down
          rotation: 0.005,
          file: "jupiter.glb",
          info: "Largest planet.",
        },
        {
          name: "Saturn",
          radius: 17,
          distance: 155,
          speed: 0.0012, // ðŸ”¹ Slowed down
          rotation: 0.008,
          file: "saturn.glb",
          info: "Has rings.",
        },
        {
          name: "Uranus",
          radius: 18,
          distance: 170,
          speed: 0.0009,
          rotation: 0.003,
          file: "uranus.glb",
          info: "Rotates on side.",
        },
        // {
        //   name: "Neptune",
        //   radius: 23,
        //   distance: 200,
        //   speed: 0.0007,
        //   rotation: 0.004,
        //   file: "neptune.glb",
        //   info: "Farthest planet.",
        // },
      ];

      const planetMeshes = [];
      let planetsLoaded = 0;
      const loaderDiv = document.getElementById("loader");
      const loadingText = document.getElementById("loading-text");

      planets.forEach((planet) => {
        gltfLoader.load(`textures/models/${planet.file}`, (gltf) => {
          const mesh = gltf.scene;
          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          mesh.scale.setScalar(planet.radius / maxDim);

          const pivot = new THREE.Object3D();
          pivot.userData.angle = Math.random() * Math.PI * 2;
          pivot.add(mesh);
          solarSystem.add(pivot);

          mesh.position.x = planet.distance;
          mesh.position.z = 0;

          if (planet.distance > 0) {
            const orbit = new THREE.RingGeometry(
              planet.distance - 0.05,
              planet.distance + 0.05,
              128
            );
            const orbitMat = new THREE.MeshBasicMaterial({
              color: 0x888888,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 1,
            });
            const orbitMesh = new THREE.Mesh(orbit, orbitMat);
            orbitMesh.rotation.x = Math.PI / 2;
            scene.add(orbitMesh);
          }

          const div = document.createElement("div");
          div.className = "planet-label";
          div.textContent = `${planet.name}: ${planet.info}`;
          const label = new THREE.CSS2DObject(div);
          label.position.set(0, size.y / 2 + 2, 0);
          label.visible = false;
          mesh.add(label);

          planetMeshes.push({ mesh, pivot, planet, label, bbox });

          planetsLoaded++;
          loadingText.textContent = `Loading ${Math.floor(
            (planetsLoaded / planets.length) * 100
          )}%`;

          if (planetsLoaded === planets.length) {
            gsap.to(loaderDiv, {
              opacity: 0,
              duration: 1,
              onComplete: () => {
                loaderDiv.style.display = "none";
                gsap
                  .timeline()
                  .to(solarSystem.scale, {
                    x: 2,
                    y: 2,
                    z: 2,
                    duration: 2,
                    ease: "power2.out",
                  })
                  .to(solarSystem.rotation, {
                    y: "-=" + Math.PI * 4,
                    duration: 2,
                    ease: "power1.inOut",
                  })
                  .to(solarSystem.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.5,
                    ease: "power2.out",
                  });
              },
            });
          }
        });
      });

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      function animate() {
        requestAnimationFrame(animate);
        planetMeshes.forEach((p) => {
          if (p.planet.distance > 0) {
            p.pivot.userData.angle += p.planet.speed;
            const a = p.pivot.userData.angle;
            p.mesh.position.x = Math.cos(a) * p.planet.distance;
            p.mesh.position.z = Math.sin(a) * p.planet.distance;
          }
          p.mesh.rotation.y += p.planet.rotation;
          p.label.visible = false;
        });

        if (planetsLoaded === planets.length) {
          raycaster.setFromCamera(mouse, camera);
          const objectsToIntersect = [];
          planetMeshes.forEach((p) =>
            p.mesh.traverse((c) => c.isMesh && objectsToIntersect.push(c))
          );
          const intersects = raycaster.intersectObjects(objectsToIntersect);
          if (intersects.length > 0) {
            let obj = intersects[0].object;
            let p = null;
            while (obj) {
              p = planetMeshes.find(
                (pm) => pm.mesh === obj || pm.mesh.children.includes(obj)
              );
              if (p) break;
              obj = obj.parent;
            }
            if (p) p.label.visible = true;
          }
        }

        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
