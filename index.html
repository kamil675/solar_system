<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Solar System - Scroll Controlled</title>
    <style>
      body {
        margin: 0;
        height: 400vh; /* scroll ke liye extra height */
        background: black;
        font-family: Arial, sans-serif;
        overflow: hidden; /* scroll handled manually */
      }
      .planet-label {
        color: white;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
        text-align: center;
        text-shadow: 0 0 5px black;
      }
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: black;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      #loading-text {
        color: white;
        font-size: 18px;
        margin-top: 20px;
      }
      #astronaut {
        position: fixed;
        top: 40%; /* initial top */
        left: 50%;
        width: 350px;
        height: 250px;
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        visibility: hidden;
        /* transition: all 0.1s ease; */
      }

      .info-box {
        background: white;
        color: black;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        max-width: 200px;
        text-align: left;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="loader">
      <canvas id="loaderCanvas" width="200" height="200"></canvas>
      <div id="loading-text">Loading 0%</div>
    </div>
    <img id="astronaut" src="textures/models/astronaut.png" alt="Astronaut" />

    <!-- ===== Libraries ===== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
      // ===== Loader Animation =====
      const loaderCanvas = document.getElementById("loaderCanvas");
      const ctx = loaderCanvas.getContext("2d");
      const loaderSunRadius = 20;
      const miniPlanets = [];
      for (let i = 0; i < 5; i++) {
        miniPlanets.push({
          radius: Math.random() * 40 + 20,
          size: Math.random() * 3 + 2,
          speed: Math.random() * 0.03 + 0.01,
          angle: Math.random() * Math.PI * 2,
          color: `hsl(${Math.random() * 360},80%,60%)`,
        });
      }
      function drawLoader() {
        ctx.clearRect(0, 0, loaderCanvas.width, loaderCanvas.height);
        ctx.save();
        ctx.translate(loaderCanvas.width / 2, loaderCanvas.height / 2);

        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, loaderSunRadius);
        grad.addColorStop(0, "#ffff33");
        grad.addColorStop(1, "rgba(255,255,0,0)");
        ctx.beginPath();
        ctx.arc(0, 0, loaderSunRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        miniPlanets.forEach((p) => {
          p.angle += p.speed;
          const x = Math.cos(p.angle) * p.radius;
          const y = Math.sin(p.angle) * p.radius;
          const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, p.size);
          planetGrad.addColorStop(0, "white");
          planetGrad.addColorStop(0.3, p.color);
          planetGrad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.beginPath();
          ctx.arc(x, y, p.size + 2, 0, Math.PI * 2);
          ctx.fillStyle = planetGrad;
          ctx.fill();
        });
        ctx.restore();
        requestAnimationFrame(drawLoader);
      }
      drawLoader();

      // ===== Three.js Scene =====
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 50, 350);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      const labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = "absolute";
      labelRenderer.domElement.style.top = "0px";
      labelRenderer.domElement.style.pointerEvents = "none";
      document.body.appendChild(labelRenderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.enablePan = false;

      scene.add(new THREE.AmbientLight(0xffffff, 0.15));
      const fillLight1 = new THREE.PointLight(0xffffff, 0.3, 2000);
      fillLight1.position.set(500, 200, 500);
      scene.add(fillLight1);
      const fillLight2 = new THREE.PointLight(0xffffff, 0.25, 2000);
      fillLight2.position.set(-400, -200, -300);
      scene.add(fillLight2);

      // ===== Stars =====
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2500; // zyada stars for wide fill
      const starVertices = [];
      const starSpeeds = [];

      // 🌌 Spread stars in huge 3D space (not just small cube)
      const spread = 6000;

      for (let i = 0; i < starCount; i++) {
        const r = Math.random() * spread;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        starVertices.push(x, y, z);
        starSpeeds.push(Math.random() * 0.05 + 0.01);
      }

      starGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );

      const starTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/circle.png"
      );
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,
        map: starTexture,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      // ✨ Infinite drift effect (without forming box or cluster)
      function animateStars(factor = 1) {
        const positions = stars.geometry.attributes.position.array;
        const verticalLimit = spread / 2;

        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += starSpeeds[i / 3] * factor;

          // reset from top to bottom
          if (positions[i + 1] > verticalLimit) {
            positions[i + 1] = -verticalLimit;
            positions[i] = (Math.random() - 0.5) * spread;
            positions[i + 2] = (Math.random() - 0.5) * spread;
          }
        }

        stars.geometry.attributes.position.needsUpdate = true;
      }

      // ===== Solar System =====
      const gltfLoader = new THREE.GLTFLoader();
      const solarSystem = new THREE.Group();
      solarSystem.scale.set(0.01, 0.01, 0.01);
      solarSystem.visible = false;

      // ✅ Add tilt here:
      solarSystem.rotation.x = THREE.MathUtils.degToRad(70);

      scene.add(solarSystem);

      const planets = [
        {
          name: "Sun",
          radius: 46,
          distance: 0,
          speed: 0,
          rotation: 0.001,
          file: "the_star_sun.glb",
          info: "The Sun, star at center.",
        },
        {
          name: "Mercury",
          radius: 6,
          distance: 30,
          speed: 0.008,
          rotation: 0.004,
          file: "mercury.glb",
          info: "Closest planet to Sun.",
        },
        {
          name: "Venus",
          radius: 9,
          distance: 53,
          speed: 0.006,
          rotation: 0.002,
          file: "venus.glb",
          info: "Very hot planet.",
        },
        {
          name: "Earth",
          radius: 11,
          distance: 75,
          speed: 0.004,
          rotation: 0.01,
          file: "earth.glb",
          info: "Our home planet.",
        },
        {
          name: "Mars",
          radius: 13,
          distance: 95,
          speed: 0.003,
          rotation: 0.008,
          file: "mars.glb",
          info: "Red planet.",
        },
        {
          name: "Jupiter",
          radius: 17,
          distance: 125,
          speed: 0.0015,
          rotation: 0.005,
          file: "jupiter.glb",
          info: "Largest planet.",
        },
        {
          name: "Saturn",
          radius: 16,
          distance: 145,
          speed: 0.0012,
          rotation: 0.008,
          file: "saturn.glb",
          info: "Has rings.",
        },
        {
          name: "Uranus",
          radius: 13,
          distance: 160,
          speed: 0.0009,
          rotation: 0.003,
          file: "uranus.glb",
          info: "Rotates on side.",
        },
        {
          name: "Neptune",
          radius: 10,
          distance: 185,
          speed: 0.0009,
          rotation: 0.003,
          file: "neptune.glb",
          info: "Rotates on side.",
        },
      ];

      const planetMeshes = [];
      const orbitMeshes = [];
      let planetsLoaded = 0;
      const loaderDiv = document.getElementById("loader");
      const loadingText = document.getElementById("loading-text");
      const spriteTexture = new THREE.TextureLoader().load(
        "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png"
      );

      function addGlowSpriteToMesh(
        mesh,
        size,
        color = 0xffe066,
        opacity = 0.15
      ) {
        const spriteMat = new THREE.SpriteMaterial({
          map: spriteTexture,
          color,
          transparent: true,
          opacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(size, size, 1);
        mesh.add(sprite);
        sprite.position.set(0, 0, -size * 0.02);
        return sprite;
      }

      function loadPlanetModel(planet) {
        gltfLoader.load(`textures/models/${planet.file}`, (gltf) => {
          const mesh = gltf.scene;
          const bbox = new THREE.Box3().setFromObject(mesh);
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          mesh.position.sub(center);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          let scaleFactor = planet.radius / Math.max(size.x, size.y, size.z);
          if (planet.name === "Sun") scaleFactor *= 0.8;
          mesh.scale.setScalar(scaleFactor);

          if (planet.name === "Sun") {
            const coreLight = new THREE.PointLight(0xffd966, 1.2, 1500);
            mesh.add(coreLight);
            const redGlow = new THREE.PointLight(0xff3300, 0.2, 2500);
            mesh.add(redGlow);
            const yellowGlow = new THREE.PointLight(0xffee88, 0.5, 1500);
            mesh.add(yellowGlow);
            mesh.traverse((child) => {
              if (child.isMesh && child.material) {
                try {
                  child.material.emissive = new THREE.Color(0xffb84d);
                  child.material.emissiveIntensity = 0.4;
                } catch (e) {}
              }
            });
            const glowSprite = addGlowSpriteToMesh(mesh, 250, 0xffe066, 0.12);
            const flicker = { t: 0 };
            const updateFlicker = () => {
              flicker.t += 0.035;
              coreLight.intensity = 2 + Math.sin(flicker.t * 1.2) * 0.1;
              yellowGlow.intensity = 0.5 + Math.sin(flicker.t * 0.8) * 0.05;
              redGlow.intensity = 0.2 + Math.sin(flicker.t * 0.6) * 0.03;
              if (glowSprite && glowSprite.material)
                glowSprite.material.opacity =
                  0.25 + Math.sin(flicker.t * 0.4) * 0.02;
              requestAnimationFrame(updateFlicker);
            };
            updateFlicker();
          } else {
            addGlowSpriteToMesh(mesh, planet.radius * 10 + 40, 0xffffff, 0.08);
          }

          const pivot = new THREE.Object3D();
          pivot.userData.angle = Math.random() * Math.PI * 2;
          pivot.add(mesh);

          // 🌍 RANDOM POSITION ON SAME DISTANCE (no linear alignment)
          const randomAngle = Math.random() * Math.PI * 2;
          mesh.position.x = planet.distance * Math.cos(randomAngle);
          mesh.position.z = planet.distance * Math.sin(randomAngle);
          mesh.position.y = (Math.random() - 0.5) * 10; // slight vertical variance

          solarSystem.add(pivot);

          // orbit
          if (planet.distance > 0) {
            let orbitMesh;
            const ringGeometry = new THREE.RingGeometry(
              planet.distance - 0.08,
              planet.distance + 0.08,
              128
            );
            const ringMaterial = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending,
            });
            orbitMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            orbitMesh.rotation.x = Math.PI / 2 - THREE.MathUtils.degToRad(20);

            if (planet.name === "Mercury") {
              // ✅ Mercury ring visible & inside pivot so it rotates with planet
              orbitMesh.visible = true;
              pivot.add(orbitMesh);
            } else {
              // Other planets' orbit rings
              orbitMesh.visible = false; // initially invisible
              solarSystem.add(orbitMesh);
            }

            orbitMeshes.push(orbitMesh);
          }

          const div = document.createElement("div");
          div.className = "planet-label";
          div.textContent = `${planet.name}: ${planet.info}`;
          const label = new THREE.CSS2DObject(div);
          let labelY = planet.radius + 5;
          if (planet.name === "Earth") labelY = planet.radius - 11;
          if (planet.name === "Mars") labelY = planet.radius - 12;
          if (planet.name === "Uranus") labelY = planet.radius - 11;
          if (planet.name === "Sun") labelY = planet.radius - 22;
          label.position.set(0, labelY, 0);
          label.visible = false;
          mesh.add(label);

          planetMeshes.push({ mesh, pivot, planet, label });
          planetsLoaded++;
          loadingText.textContent = `Loading ${Math.floor(
            (planetsLoaded / planets.length) * 100
          )}%`;
          if (planetsLoaded === planets.length) {
            // Hide loader instantly
            loaderDiv.style.opacity = 0;
            loaderDiv.style.display = "none";

            // Show astronaut and Heyfynix text immediately
            const astronautImg = document.getElementById("astronaut");
            astronautImg.style.visibility = "visible";
            astronautImg.style.opacity = 1;

            // Show solar system immediately
            solarSystem.visible = true;
          }
        });
      }

      planets.forEach((p) => loadPlanetModel(p));

      // ===== Special Moon =====
      const specialMoon = { mesh: null, info: null };
      gltfLoader.load("textures/models/moon1.glb", (gltf) => {
        const mesh = gltf.scene;
        mesh.scale.set(1, 1, 1);
        mesh.position.set(0, -window.innerHeight * 0.5, 0);
        scene.add(mesh);
        specialMoon.mesh = mesh;

        const infoDiv = document.createElement("div");
        infoDiv.className = "info-box";
        infoDiv.textContent =
          "Moon is Earth's only natural satellite with 27% of Earth's size.";
        const infoLabel = new THREE.CSS2DObject(infoDiv);
        infoLabel.position.set(200, 0, 0);
        mesh.add(infoLabel);
        specialMoon.info = infoDiv;

        setTimeout(() => mesh.remove(infoLabel), 1000);
      });

      // ===== Scroll Handling =====
      let scrollProgress = 0;
      let targetScroll = 0;
      const scrollHeight = window.innerHeight * 4;
      let touchStartY = 0;

      window.addEventListener("wheel", (e) => {
        targetScroll += e.deltaY;
        targetScroll = Math.min(Math.max(targetScroll, 0), scrollHeight);
      });
      window.addEventListener("touchstart", (e) => {
        touchStartY = e.touches[0].clientY;
      });
      window.addEventListener("touchmove", (e) => {
        const deltaY = touchStartY - e.touches[0].clientY;
        targetScroll += deltaY;
        targetScroll = Math.min(Math.max(targetScroll, 0), scrollHeight);
        touchStartY = e.touches[0].clientY;
      });

      function updateScrollAnimation() {
        scrollProgress += (targetScroll - scrollProgress) * 0.08;
        const eased = Math.min(Math.max(scrollProgress / scrollHeight, 0), 1);

        // ===== Astronaut =====
        const astronaut = document.getElementById("astronaut");
        const astroStartY = 40; // initial top %
        const astroEndY = 35; // upar jaake disappear
        const astroStartScale = 1.3; // initial size
        const astroEndScale = 0;
        const astroStartOpacity = 1;
        const astroEndOpacity = 0;
        const astroProgress = Math.min(eased / 0.7, 1);

        const moveY = astroStartY + (astroEndY - astroStartY) * astroProgress;
        astronaut.style.transform = `translate(-50%, ${-50 + moveY}%) scale(${
          astroStartScale + (astroEndScale - astroStartScale) * astroProgress
        })`;

        astronaut.style.opacity =
          astroStartOpacity +
          (astroEndOpacity - astroStartOpacity) * astroProgress;

        // ===== Moon =====
        const moonStartY = -window.innerHeight * 0.6;
        const moonEndY = 0; // center of screen
        const moonStartScale = 2.5; // initial large size
        const moonEndScale = 0; // final normal size

        if (specialMoon.mesh) {
          // Smooth moon scroll like astronaut
          if (!specialMoon.scrollY) specialMoon.scrollY = moonStartY;
          if (!specialMoon.scaleVal) specialMoon.scaleVal = moonStartScale;

          const moonTargetY =
            moonStartY + (moonEndY - moonStartY) * Math.min(eased / 0.7, 1);
          specialMoon.scrollY += (moonTargetY - specialMoon.scrollY) * 0.08; // smoothing
          specialMoon.mesh.position.y = specialMoon.scrollY;

          const moonTargetScale =
            moonStartScale +
            (moonEndScale - moonStartScale) * Math.min(eased / 0.7, 1);
          specialMoon.scaleVal +=
            (moonTargetScale - specialMoon.scaleVal) * 0.08; // smoothing
          specialMoon.mesh.scale.set(
            specialMoon.scaleVal,
            specialMoon.scaleVal,
            specialMoon.scaleVal
          );

          specialMoon.mesh.visible = true;
        }

        // ===== Solar System =====
        const solarStartY = -window.innerHeight * 0.99;
        const solarEndY = 0;
        const solarStartScale = 0.4;
        const solarEndScale = 1;
        const solarProgress = Math.min(Math.max((eased - 0.15) / 0.85, 0), 1);

        solarSystem.position.y =
          solarStartY + (solarEndY - solarStartY) * solarProgress;
        solarSystem.scale.setScalar(
          solarStartScale + (solarEndScale - solarStartScale) * solarProgress
        );

        // ===== Camera =====
        const camStartZ = 350;
        const camEndZ = 200;
        camera.position.z = camStartZ + (camEndZ - camStartZ) * solarProgress;
        camera.lookAt(0, 0, 0);
      }

      function updateMeshMap() {
        planetMeshes.forEach(({ mesh, pivot, planet }) => {
          pivot.rotation.y += planet.speed;
          mesh.rotation.y += planet.rotation;
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        updateMeshMap();
        animateStars(1);
        updateScrollAnimation();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
